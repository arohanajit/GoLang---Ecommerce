# E-Commerce Platform Development Log

## 1. Progress So Far

### Completed Tasks:
1. Set up basic project structure with microservices architecture
2. Implemented Product Service with:
   - CRUD operations for products
   - PostgreSQL database integration
   - Service registration with Consul
   - Health check endpoints
   - Logging middleware

3. Implemented API Gateway with:
   - Service discovery using Consul
   - Request routing and forwarding
   - Health check endpoints
   - Graceful shutdown

4. Set up Service Discovery:
   - Integrated Consul for service registry
   - Implemented health checks
   - Service registration/deregistration

5. Database Setup:
   - PostgreSQL integration
   - GORM for ORM
   - Auto-migrations
   - UUID support
   - Configured user permissions and authentication

6. Implemented Order Service with:
   - Basic CRUD operations for orders
   - PostgreSQL database integration with proper authentication
   - Service registration with Consul
   - Health check endpoints
   - Order and OrderItem models
   - Relationship handling between orders and items

## 2. Project Structure 

e-commerce-platform/
├── gateway/
│ ├── main.go # API Gateway implementation
│ ├── .env # Gateway configuration
│ └── .gitignore
└── services/
└── product/
├── main.go # Product service entry point
├── handlers.go # Product CRUD handlers
├── models.go # Product data models
├── .env # Service configuration
└── .gitignore
└── order/
├── main.go # Order service entry point
├── handlers.go # Order CRUD handlers
├── models.go # Order and OrderItem models
├── .env # Service configuration
└── .gitignore

## 3. Database Configuration

### Product Service Database:
- Database: product_db
- User: product_user
- Authentication: Password-based
- Schema: public with proper permissions
- Extensions: uuid-ossp for UUID generation

### Order Service Database:
- Database: order_db
- User: order_user
- Authentication: Password-based
- Schema: public with proper permissions
- Extensions: uuid-ossp for UUID generation

## 4. Service Details

### Order Service Models:
```go
// Order represents the order data model
type Order struct {
    gorm.Model
    ID            string      `json:"id" gorm:"type:uuid;default:uuid_generate_v4()"`
    UserID        string      `json:"user_id" gorm:"type:uuid;not null"`
    Items         []OrderItem `json:"items" gorm:"foreignKey:OrderID"`
    TotalAmount   float64     `json:"total_amount" gorm:"not null"`
    Status        string      `json:"status" gorm:"default:'pending'"`
    PaymentStatus string      `json:"payment_status" gorm:"default:'unpaid'"`
    CreatedAt     time.Time   `json:"created_at"`
    UpdatedAt     time.Time   `json:"updated_at"`
}

// OrderItem represents an item in an order
type OrderItem struct {
    gorm.Model
    OrderID   string  `json:"order_id" gorm:"type:uuid;not null"`
    ProductID string  `json:"product_id" gorm:"type:uuid;not null"`
    Quantity  int     `json:"quantity" gorm:"not null"`
    Price     float64 `json:"price" gorm:"not null"`
}
```

### Order Service Endpoints:
- GET /api/v1/orders - List all orders
- POST /api/v1/orders - Create a new order
- GET /api/v1/orders/:id - Get order details
- PUT /api/v1/orders/:id - Update order
- DELETE /api/v1/orders/:id - Delete order

### Services/Order/main.go:
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "strconv"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/hashicorp/consul/api"
    "github.com/joho/godotenv"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

func main() {
    // Load environment variables
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }

    // Initialize database
    db, err := initDB()
    if err != nil {
        log.Fatal("Failed to initialize database:", err)
    }

    // Consul client config
    consulConfig := api.DefaultConfig()
    consulConfig.Address = os.Getenv("CONSUL_HTTP_ADDR")
    if consulConfig.Address == "" {
        consulConfig.Address = "http://localhost:8500"
    }

    consulClient, err := api.NewClient(consulConfig)
    if err != nil {
        log.Fatalf("Failed to create Consul client: %v", err)
    }

    // Register Order Service with Consul
    orderPort, _ := strconv.Atoi(os.Getenv("PORT"))
    registration := &api.AgentServiceRegistration{
        ID:      "order-service-" + os.Getenv("HOST_IP"),
        Name:    "order-service",
        Port:    orderPort,
        Address: os.Getenv("HOST_IP"),
        Check: &api.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", os.Getenv("HOST_IP"), orderPort),
            Interval:                       "10s",
            Timeout:                        "1s",
            DeregisterCriticalServiceAfter: "30s",
        },
        Tags: []string{"order", "api"},
    }

    err = consulClient.Agent().ServiceRegister(registration)
    if err != nil {
        log.Fatalf("Failed to register order service with Consul: %v", err)
    }

    // Deregister Order Service on exit
    defer consulClient.Agent().ServiceDeregister(registration.ID)

    // Initialize Gin router
    router := gin.Default()
    router.Use(gin.Logger())

    // Basic health check endpoint
    router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"status": "UP"})
    })

    // Setup routes
    v1 := router.Group("/api/v1/orders")
    {
        v1.GET("", ListOrders(db))
        v1.POST("", CreateOrder(db))
        v1.GET("/:id", GetOrder(db))
        v1.PUT("/:id", UpdateOrder(db))
        v1.DELETE("/:id", DeleteOrder(db))
    }

    // Configure server
    port := os.Getenv("PORT")
    if port == "" {
        port = "8001"
    }

    srv := &http.Server{
        Addr:    ":" + port,
        Handler: router,
    }

    // Start server in a goroutine
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Failed to start server: %v", err)
        }
    }()

    // Wait for interrupt signal to gracefully shutdown the server
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    log.Println("Shutting down server...")

    // Shutdown the server with a timeout
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }

    log.Println("Server exiting")
}

func initDB() (*gorm.DB, error) {
    dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
        os.Getenv("DB_HOST"),
        os.Getenv("DB_USER"),
        os.Getenv("DB_PASSWORD"),
        os.Getenv("DB_NAME"),
        os.Getenv("DB_PORT"),
    )

    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        return nil, fmt.Errorf("failed to initialize database: %w", err)
    }

    // Auto-migrate the Order and OrderItem models
    if err := db.AutoMigrate(&Order{}, &OrderItem{}); err != nil {
        return nil, fmt.Errorf("failed to auto-migrate models: %w", err)
    }

    return db, nil
}
```

### Services/Order/handlers.go:
```go
package main

import (
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

// ListOrders handles GET /api/v1/orders
func ListOrders(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var orders []Order
        if err := db.Preload("Items").Find(&orders).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        c.JSON(http.StatusOK, orders)
    }
}

// CreateOrder handles POST /api/v1/orders
func CreateOrder(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var order Order
        if err := c.ShouldBindJSON(&order); err != nil {
            log.Printf("Error binding JSON: %v", err)
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Start a transaction
        tx := db.Begin()
        if tx.Error != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
            return
        }

        // Create the order
        if err := tx.Create(&order).Error; err != nil {
            tx.Rollback()
            log.Printf("Error creating order: %v", err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create order"})
            return
        }

        // Create order items
        for i := range order.Items {
            order.Items[i].OrderID = order.ID
            if err := tx.Create(&order.Items[i]).Error; err != nil {
                tx.Rollback()
                log.Printf("Error creating order item: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create order items"})
                return
            }
        }

        // Commit the transaction
        if err := tx.Commit().Error; err != nil {
            log.Printf("Error committing transaction: %v", err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
            return
        }

        log.Printf("Successfully created order with ID: %s", order.ID)
        c.JSON(http.StatusCreated, order)
    }
}

// GetOrder handles GET /api/v1/orders/:id
func GetOrder(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")
        var order Order
        if err := db.Preload("Items").First(&order, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
            return
        }
        c.JSON(http.StatusOK, order)
    }
}

// UpdateOrder handles PUT /api/v1/orders/:id
func UpdateOrder(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")
        var order Order
        if err := db.Preload("Items").First(&order, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
            return
        }

        var updatedOrder Order
        if err := c.ShouldBindJSON(&updatedOrder); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Start a transaction
        tx := db.Begin()
        if tx.Error != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
            return
        }

        // Update order details
        if err := tx.Model(&order).Updates(map[string]interface{}{
            "user_id":        updatedOrder.UserID,
            "total_amount":   updatedOrder.TotalAmount,
            "status":        updatedOrder.Status,
            "payment_status": updatedOrder.PaymentStatus,
        }).Error; err != nil {
            tx.Rollback()
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        // Delete existing items
        if err := tx.Where("order_id = ?", order.ID).Delete(&OrderItem{}).Error; err != nil {
            tx.Rollback()
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update order items"})
            return
        }

        // Create new items
        for _, item := range updatedOrder.Items {
            item.OrderID = order.ID
            if err := tx.Create(&item).Error; err != nil {
                tx.Rollback()
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create new order items"})
                return
            }
        }

        // Commit the transaction
        if err := tx.Commit().Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
            return
        }

        // Fetch the updated order with items
        var updatedOrderWithItems Order
        if err := db.Preload("Items").First(&updatedOrderWithItems, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch updated order"})
            return
        }

        c.JSON(http.StatusOK, updatedOrderWithItems)
    }
}

// DeleteOrder handles DELETE /api/v1/orders/:id
func DeleteOrder(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")

        // Start a transaction
        tx := db.Begin()
        if tx.Error != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
            return
        }

        // Delete order items first
        if err := tx.Where("order_id = ?", id).Delete(&OrderItem{}).Error; err != nil {
            tx.Rollback()
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete order items"})
            return
        }

        // Delete the order
        if err := tx.Delete(&Order{}, "id = ?", id).Error; err != nil {
            tx.Rollback()
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete order"})
            return
        }

        // Commit the transaction
        if err := tx.Commit().Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "Order deleted"})
    }
}
```

[... keep existing code for Gateway/main.go, Services/Product/main.go, etc. ...]

### Gateway/main.go:
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "net/http/httputil"
    "net/url"
    "os"
    "os/signal"
    "strconv"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/hashicorp/consul/api"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables from .env file
    if err := godotenv.Load(); err != nil {
        log.Fatal("Error loading .env file:", err)
    }

    // Get the PORT from the environment, or default to 8081
    port, err := strconv.Atoi(os.Getenv("PORT"))
    if err != nil {
        log.Fatal("Error: PORT must be a number:", err)
    }
    if port == 0 {
        port = 8081
    }

    // Initialize Gin router
    r := gin.Default()

    // Consul client config
    consulConfig := api.DefaultConfig()
    consulConfig.Address = os.Getenv("CONSUL_HTTP_ADDR")
    if consulConfig.Address == "" {
        consulConfig.Address = "http://localhost:8500"
    }

    consulClient, err := api.NewClient(consulConfig)
    if err != nil {
        log.Fatalf("Failed to create Consul client: %v", err)
    }

    // Register API Gateway with Consul
    registration := new(api.AgentServiceRegistration)
    registration.ID = "api-gateway"              // Unique ID for this instance
    registration.Name = "api-gateway"            // Service name
    registration.Port = port                     // API Gateway port
    registration.Address = os.Getenv("HOST_IP")  // Host IP or network interface
    registration.Check = &api.AgentServiceCheck{ // Simple health check
        HTTP:     fmt.Sprintf("http://%s:%d/health", registration.Address, registration.Port),
        Interval: "10s",
        Timeout:  "1s",
    }

    err = consulClient.Agent().ServiceRegister(registration)
    if err != nil {
        log.Fatalf("Failed to register service: %v", err)
    }

    // Deregister API Gateway on exit
    defer consulClient.Agent().ServiceDeregister(registration.ID)

    // Basic health check endpoint
    r.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"status": "UP"})
    })

    // Placeholder routes
    v1 := r.Group("/api/v1")
    {
        // Product routes with service discovery and reverse proxy
        products := v1.Group("/products")
        {
            productService := "product-service"
            products.Any("", proxyToService(consulClient, productService, "/api/v1/products"))
            products.Any("/*path", proxyToService(consulClient, productService, "/api/v1/products"))
        }

        // Order routes with service discovery and reverse proxy
        orders := v1.Group("/orders")
        {
            orderService := "order-service"
            orders.Any("", proxyToService(consulClient, orderService, "/api/v1/orders"))
            orders.Any("/*path", proxyToService(consulClient, orderService, "/api/v1/orders"))
        }

        users := v1.Group("/users")
        {
            users.POST("/register", placeholderHandler("User Service - Register"))
            users.POST("/login", placeholderHandler("User Service - Login"))
            users.GET("/me", placeholderHandler("User Service - Profile"))
        }
    }

    // Configure graceful shutdown
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", port),
        Handler: r,
    }

    // Handle shutdown gracefully
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Failed to start server: %v", err)
        }
    }()

    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    log.Println("Shutting down server...")

    // Shutdown gracefully
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }

    log.Println("Server exiting")
}

// proxyToService forwards requests to the appropriate microservice
func proxyToService(consulClient *api.Client, serviceName, targetPath string) gin.HandlerFunc {
    return func(c *gin.Context) {
        log.Printf("Incoming request to gateway: %s %s", c.Request.Method, c.Request.URL.Path)
        services, _, err := consulClient.Health().Service(serviceName, "", true, nil)
        if err != nil {
            log.Printf("Error discovering service: %v", err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover service"})
            return
        }

        if len(services) == 0 {
            log.Printf("No healthy instances found for service: %s", serviceName)
            c.JSON(http.StatusNotFound, gin.H{"error": "Service not found"})
            return
        }

        service := services[0].Service
        
        targetURL := &url.URL{
            Scheme: "http",
            Host:   fmt.Sprintf("%s:%d", service.Address, service.Port),
        }

        // Log the target service details
        log.Printf("Forwarding to service: %s at %s", serviceName, targetURL.String())

        proxy := httputil.NewSingleHostReverseProxy(targetURL)

        // Modify director to properly handle paths
        originalDirector := proxy.Director
        proxy.Director = func(req *http.Request) {
            originalDirector(req)
            // Keep the path from the gateway request
            req.URL.Scheme = targetURL.Scheme
            req.URL.Host = targetURL.Host
            // Log the final request URL
            log.Printf("Final request URL: %s", req.URL.String())
        }

        // Set headers
        c.Request.Header.Set("X-Forwarded-Host", c.Request.Host)
        c.Request.Header.Set("X-Forwarded-Proto", c.Request.Proto)
        c.Request.Header.Set("X-Forwarded-For", c.ClientIP())

        proxy.ServeHTTP(c.Writer, c.Request)
    }
}

// placeholderHandler creates a simple handler that returns a message indicating which service it's for.
func placeholderHandler(serviceName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "Response from API Gateway - " + serviceName,
        })
    }
}
```

### Services/Product/main.go:
```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "os"
    "strconv"

    "github.com/gin-gonic/gin"
    "github.com/hashicorp/consul/api"
    "github.com/joho/godotenv"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

func main() {
    // Load environment variables
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }

    // Database connection details
    dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
        os.Getenv("DB_HOST"),
        os.Getenv("DB_USER"),
        os.Getenv("DB_PASSWORD"),
        os.Getenv("DB_NAME"),
        os.Getenv("DB_PORT"),
    )

    // Connect to the database
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // Migrate the schema
    db.AutoMigrate(&Product{})

    // Consul client config
    consulConfig := api.DefaultConfig()
    consulConfig.Address = os.Getenv("CONSUL_HTTP_ADDR")
    if consulConfig.Address == "" {
        consulConfig.Address = "http://localhost:8500" // Default Consul address
    }
    consulClient, err := api.NewClient(consulConfig)
    if err != nil {
        log.Fatalf("Failed to create Consul client: %v", err)
    }

    // Register Product Service with Consul
    productPort, _ := strconv.Atoi(os.Getenv("PORT"))
    registration := &api.AgentServiceRegistration{
        ID:      "product-service-" + os.Getenv("HOST_IP"),
        Name:    "product-service",
        Port:    productPort,
        Address: os.Getenv("HOST_IP"),
        Check: &api.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", os.Getenv("HOST_IP"), productPort),
            Interval:                       "10s",
            Timeout:                        "1s",
            DeregisterCriticalServiceAfter: "30s",
        },
        Tags: []string{"product", "api"},
    }

    err = consulClient.Agent().ServiceRegister(registration)
    if err != nil {
        log.Fatalf("Failed to register product service with Consul: %v", err)
    }

    // Deregister Product Service on exit
    defer consulClient.Agent().ServiceDeregister(registration.ID)

    // Initialize Gin router
    router := gin.Default()

    // Add this before setting up routes
    router.Use(gin.Logger())
    router.Use(func(c *gin.Context) {
        log.Printf("Product Service received request: %s %s", c.Request.Method, c.Request.URL.Path)
        c.Next()
    })

    // Basic health check endpoint for the Product Service
    router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"status": "UP"})
    })

    // Setup routes
    v1 := router.Group("/api/v1/products")
    {
        v1.GET("", func(c *gin.Context) {
            log.Printf("Handling GET request for products")
            ListProducts(db)(c)
        })
        v1.POST("", func(c *gin.Context) {
            log.Printf("Handling POST request for products")
            CreateProduct(db)(c)
        })
        v1.GET("/:id", GetProduct(db))
        v1.PUT("/:id", UpdateProduct(db))
        v1.DELETE("/:id", DeleteProduct(db))
    }

    // Run the server
    port := os.Getenv("PORT")
    if port == "" {
        port = "8000"
    }
    router.Run(":" + port)
}

### Services/Product/models.go:
```go
package models

import "gorm.io/gorm"

type Product struct {
    gorm.Model
    ID          string    `gorm:"primarykey;type:uuid;default:uuid_generate_v4()" json:"id"`
    Name        string    `json:"name" binding:"required"`
    Description string    `json:"description"`
    Price       float64   `json:"price" binding:"required"`
    Stock       int64     `json:"stock" binding:"required"`
    CategoryID  string    `json:"category_id"`
    Images      []string  `gorm:"type:text[]" json:"images"`
}
```

### Services/Product/handlers.go:
```go
package main

import (
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

// Product represents the product data model (updated for GORM)
type Product struct {
    gorm.Model
    ID          string   `json:"id" gorm:"type:uuid;default:uuid_generate_v4()"`
    Name        string   `json:"name" gorm:"not null"`
    Description string   `json:"description"`
    Price       float64  `json:"price" gorm:"not null"`
    Stock       int      `json:"stock" gorm:"not null"`
    CategoryID  string   `json:"category_id"`
    Images      []string `json:"images" gorm:"-"` // Ignore this field for now
}

// ListProducts handles GET /api/products
func ListProducts(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var products []Product
        if err := db.Find(&products).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        c.JSON(http.StatusOK, products)
    }
}

// CreateProduct handles POST /api/products
func CreateProduct(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var product Product
        if err := c.ShouldBindJSON(&product); err != nil {
            log.Printf("Error binding JSON: %v", err)
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        log.Printf("Creating product: %+v", product)
        if err := db.Create(&product).Error; err != nil {
            log.Printf("Error creating product: %v", err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create product"})
            return
        }

        log.Printf("Successfully created product with ID: %s", product.ID)
        c.JSON(http.StatusCreated, product)
    }
}

// GetProduct handles GET /api/products/:id
func GetProduct(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")
        var product Product
        if err := db.First(&product, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
            return
        }
        c.JSON(http.StatusOK, product)
    }
}

// UpdateProduct handles PUT /api/products/:id
func UpdateProduct(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")
        var product Product
        if err := db.First(&product, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
            return
        }

        var updatedProduct Product
        if err := c.ShouldBindJSON(&updatedProduct); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Only update specified fields
        if err := db.Model(&product).Updates(updatedProduct).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, product)
    }
}

// DeleteProduct handles DELETE /api/products/:id
func DeleteProduct(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        id := c.Param("id")
        if err := db.Delete(&Product{}, "id = ?", id).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        c.JSON(http.StatusOK, gin.H{"message": "Product deleted"})
    }
}